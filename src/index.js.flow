// @flow
import { Emitter } from 'typed-rx-emitter'
import * as React from 'react'
import type { Observable } from 'rx'

export type Undux<Actions: {}> = $ObjMap<Actions, Hash>

type Hash = <K, V>(
  value: V,
  key: K
) => {
  key: K,
  previousValue: V,
  value: V
}

export type StoreOptions<Actions: {}> = {
  shouldEmit: (data: $Values<Undux<Actions>>) => boolean
}

declare export var defaultStoreOptions: StoreOptions<any>

declare export class Store<Actions: {}> extends Emitter<Actions> {
  constructor(state: Actions, options?: $Shape<StoreOptions<Actions>>): this;
  before<K: $Keys<Actions>>(
    key: K
  ): Observable<$ElementType<Undux<Actions>, K>>;
  beforeAll<K: $Keys<Actions>>(): Observable<$Values<Undux<Actions>>>;
  get<K: $Keys<Actions>>(key: K): $ElementType<Actions, K>;
  set<K: $Keys<Actions>>(
    key: K
  ): (value: $ElementType<Actions, K>) => Emitter<Actions>;
}

declare export function createStore<Actions: {}>(
  initialState: Actions,
  options?: $Shape<StoreOptions<Actions>>
): Store<Actions>

export type Plugin = <Actions: {}>(store: Store<Actions>) => Store<Actions>

declare export var withLogger: Plugin

declare export function connect<Actions: {}>(
  store: Store<Actions>
): (
  ...listenOn: $Keys<Actions>[]
) => <Props, PropsWithStore: { store: Store<Actions> } & Props>(
  Component: React.ComponentType<PropsWithStore>
) => Class<React.Component<Props>> & {
  WrappedComponent: React.ComponentType<PropsWithStore>
}
